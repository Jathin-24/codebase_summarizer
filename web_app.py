import json
import os
import streamlit as st
from pathlib import Path
from streamlit_agraph import agraph, Node, Edge, Config
from src.file_scanner import list_code_files
from src.summarizer import summarize_project

def predict_api_cost(num_files: int, avg_file_size_kb: float = 20) -> dict:
    """Predict Gemini API cost."""
    tokens_per_kb = 250
    total_input_tokens = int(num_files * avg_file_size_kb * tokens_per_kb * 1.5)
    total_output_tokens = int(total_input_tokens * 0.3)
    
    cost_per_1m_input = 0.075 / 1000000
    cost_per_1m_output = 0.3 / 1000000
    
    total_cost = (total_input_tokens * cost_per_1m_input + 
                  total_output_tokens * cost_per_1m_output)
    
    return {
        "estimated_cost_usd": round(total_cost, 4),
        "input_tokens": total_input_tokens,
        "output_tokens": total_output_tokens,
        "files": num_files
    }

def generate_readme(result: dict, root_path: str) -> str:
    """Generate production-ready README.md."""
    workflow = result.get("workflow", {})
    security = result.get("security", {"risks": []})
    
    entrypoints = workflow.get("entrypoints", [])
    top_modules = workflow.get("top_modules", [])
    
    return f"""# {os.path.basename(root_path)}

## ğŸ—ï¸ Architecture Overview
{result.get('project_summary', 'No summary available')[:500]}...

## ğŸšª Entry Points
{chr(10).join([f"- `{ep}`" for ep in entrypoints]) or 'No entry points detected'}

## ğŸ“Š Modules by Importance
{chr(10).join([f"- `{os.path.basename(m[0])}` ({m[1]:.0%})" for m in top_modules]) or 'No modules detected'}

## ğŸ›¡ï¸ Security Status
{len(security.get('risks', []))} risks detected

---
*Generated by [Codebase Workflow Summarizer](https://github.com/your-repo)*"""

def main():
    st.set_page_config(
        page_title="Codebase Summarizer", 
        layout="wide",
        initial_sidebar_state="expanded"
    )

    st.title("ğŸš€ Codebase Workflow Summarizer")
    st.markdown("**AI-powered architecture understanding & workflow visualization**")

    # Sidebar
    st.sidebar.header("ğŸ“ Project Configuration")
    
    default_path = str(Path(".").resolve())
    project_path = st.sidebar.text_input(
        "Project path",
        value=default_path,
        help="Local folder containing your codebase",
    )
    
    # COST PREDICTOR (IMPACT FEATURE #2) âœ…
    if project_path and os.path.exists(project_path):
        try:
            num_files = len(list_code_files(project_path))
            cost = predict_api_cost(num_files)
            st.sidebar.subheader("ğŸ’° Cost Preview")
            st.sidebar.metric("Est. Cost", f"${cost['estimated_cost_usd']}", delta=None)
        except:
            pass
    
    max_files = st.sidebar.slider("Max files to analyze", 10, 100, 50)
    run_button = st.sidebar.button("ğŸ” Analyze Codebase", type="primary")
    
    # Main tabs
    tab1, tab2, tab3 = st.tabs(["ğŸ“Š Project Overview", "ğŸ“ Folder Structure", "ğŸ”— Workflow Graph"])

    # RESULT STORAGE
    result = None

    if run_button and project_path:
        root = Path(project_path).resolve()
        if not root.exists():
            st.error(f"âŒ Path does not exist: {root}")
            st.stop()

        with st.spinner(f"Analyzing {len(os.listdir(root))} files..."):
            result = summarize_project(str(root))

        # Auto-save
        out_path = root / "code_summary.json"
        with out_path.open("w", encoding="utf-8") as f:
            json.dump(result, f, indent=2, ensure_ascii=False)
        st.sidebar.success(f"âœ… Saved to: `{out_path}`")

        # 1-CLICK README (IMPACT FEATURE #3) âœ…
        st.sidebar.markdown("---")
        st.sidebar.download_button(
            label="ğŸ“„ Download README.md",
            data=generate_readme(result, str(root)),
            file_name="README.md",
            mime="text/markdown",
            use_container_width=True
        )

        # TAB 1: Project Overview
        with tab1:
            st.subheader("ğŸ¯ Project Summary")
            st.markdown(result["project_summary"])
            
            st.subheader("ğŸšª Detected Entry Points")
            workflow = result["workflow"]
            if workflow["entrypoints"]:
                for ep in workflow["entrypoints"]:
                    st.success(f"â€¢ `{ep}`")
            else:
                st.warning("No obvious entry points detected")
            
            st.subheader("â­ Top Modules (by importance)")
            for path, score in workflow["top_modules"]:
                st.info(f"**{os.path.basename(path)}** ({score:.1%}) - {path}")
            
            # ğŸ”¥ SECURITY SCAN (IMPACT FEATURE #1) - ADD THIS
            st.subheader("ğŸ›¡ï¸ Security Scan")
            security = result.get("security", {"risks": []})
            if security["risks"]:
                for risk in security["risks"]:
                    st.error(f"**{os.path.basename(risk['file'])}**: {', '.join(risk['issues'])}")
            else:
                st.success(f"âœ… No security risks in {security.get('total_files_scanned', 0)} files")

        # TAB 2: Folder/File Structure
        with tab2:
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("ğŸ“ Folders")
                for folder, summary in sorted(result["folders"].items()):
                    label = folder or "Root"
                    with st.expander(f"ğŸ“ {label}"):
                        st.markdown(summary)
            
            with col2:
                st.subheader("ğŸ“„ Files")
                for path, summary in sorted(result["files"].items()):
                    with st.expander(f"ğŸ“„ {os.path.basename(path)}"):
                        st.markdown(summary)

        # TAB 3: Workflow Graph (FIXED GRAPH METRICS)
        with tab3:
            st.subheader("ğŸ”— **Live Dependency Graph** âœ¨")
            st.markdown("*Click nodes to expand â€¢ Drag to explore â€¢ Colors = language*")
            
            workflow = result["workflow"]
            graph_data = workflow["graph"]
            
            if graph_data.get("nodes"):
                # ENHANCED nodes with real grouping
                nodes = []
                node_extensions = set()
                for node_data in graph_data["nodes"]:
                    path = node_data["id"]
                    importance = workflow["important_modules"].get(path, 0)
                    
                    # Language-based colors + entrypoint highlighting
                    ext = os.path.splitext(path)[1][1:]  # py, js, etc.
                    node_extensions.add(ext)
                    base_color = {
                        'py': '#3776ab', 'js': '#f7df1e', 'ts': '#3178c6',
                        'java': '#e34f26', 'go': '#00add8', 'rs': '#dea584'
                    }.get(ext, '#909090')
                    
                    if path in workflow["entrypoints"]:
                        color = "#ff4444"  # Red for entrypoints
                        size = max(25, importance * 30 + 20)
                    else:
                        color = base_color
                        size = max(15, importance * 25 + 10)
                    
                    nodes.append(Node(
                        id=path,
                        label=os.path.basename(path),
                        title=f"{path}\nImportance: {importance:.1%}",
                        size=size,
                        color=color,
                        shape="dot"
                    ))
                
                edges = []
                for edge_data in graph_data["edges"]:
                    edges.append(Edge(
                        source=edge_data["from"], 
                        target=edge_data["to"],
                        label=edge_data.get("label", ""),
                        color="#999",
                        arrows="to"
                    ))
                
                # PROFESSIONAL config
                config = Config(
                    width=1000,
                    height=600,
                    directed=True,
                    hierarchical={"enabled": True, "levelSeparation": 200},
                    physics={"enabled": True, "barnesHut": {"gravitationalConstant": -8000}},
                    nodes={"shape": "dot"},
                    edges={"smooth": {"type": "continuous"}}
                )
                
                # RENDER INTERACTIVE GRAPH
                graph_result = agraph(nodes=nodes, edges=edges, config=config)
                
                # FIXED Stats below graph
                st.markdown("---")
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("Nodes", len(nodes))
                with col2:
                    st.metric("Edges", len(edges))
                with col3:
                    st.metric("Languages", len(node_extensions))  # âœ… FIXED
            else:
                st.warning("âš ï¸ No dependencies detected. Try a larger project with imports.")

if __name__ == "__main__":
    main()
